package kube

import (
	"context"
	"fmt"
	"github.com/go-logr/logr"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"time"

	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/util/workqueue"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/event"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

func NewPeriodicalEnqueueSource(
	client client.Client,
	logger logr.Logger,
	objList client.ObjectList,
	period time.Duration,
	option PeriodicalEnqueueSourceOption) *PeriodicalEnqueueSource {
	return &PeriodicalEnqueueSource{
		logger:  logger,
		Client:  client,
		objList: objList,
		period:  period,
		option:  option,
	}
}

// PeriodicalEnqueueSource is an implementation of interface sigs.k8s.io/controller-runtime/pkg/source/Source
// It reads the specific resources from Kubernetes/cache and enqueues them into the queue to trigger
// the reconcile logic periodically
type PeriodicalEnqueueSource struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	client.Client
	logger  logr.Logger
	objList client.ObjectList
	period  time.Duration
	option  PeriodicalEnqueueSourceOption
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VirtualMachineScheduleSnapshotList.
func (in *PeriodicalEnqueueSource) DeepCopy() *PeriodicalEnqueueSource {
	if in == nil {
		return nil
	}
	out := new(PeriodicalEnqueueSource)
	//in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PeriodicalEnqueueSource) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

type PeriodicalEnqueueSourceOption struct {
	OrderFunc func(objList client.ObjectList) client.ObjectList
}

// Start enqueue items periodically. The predicates only apply to the GenericEvent
func (p *PeriodicalEnqueueSource) Start(ctx context.Context, h handler.EventHandler, q workqueue.RateLimitingInterface, predicates ...predicate.Predicate) error {
	go wait.Until(func() {
		if err := p.List(ctx, p.objList); err != nil {
			p.logger.Error(err, "error listing resources")
			return
		}
		if meta.LenList(p.objList) == 0 {
			//p.logger.Info("no resources, skip")
			return
		}
		if p.option.OrderFunc != nil {
			p.objList = p.option.OrderFunc(p.objList)
		}
		if err := meta.EachListItem(p.objList, func(object runtime.Object) error {
			obj, ok := object.(client.Object)
			if !ok {
				p.logger.Info(fmt.Sprintf("%s's type isn't metav1.Object", object.GetObjectKind().GroupVersionKind().String()))
				return nil
			}
			event := event.GenericEvent{Object: obj}
			for _, predicate := range predicates {
				if !predicate.Generic(event) {
					//p.logger.Info("skip enqueue object %s/%s due to the predicate.", obj.GetNamespace(), obj.GetName())
					return nil
				}
			}

			q.Add(ctrl.Request{
				NamespacedName: types.NamespacedName{
					Namespace: obj.GetNamespace(),
					Name:      obj.GetName(),
				},
			})
			//p.logger.Info("resource %s/%s enqueued", obj.GetNamespace(), obj.GetName())
			return nil
		}); err != nil {
			p.logger.Error(err, "error enqueueing resources")
			return
		}
	}, p.period, ctx.Done())

	return nil
}

func (p *PeriodicalEnqueueSource) String() string {
	if p.objList != nil {
		return fmt.Sprintf("kind source: %T", p.objList)
	}
	return "kind source: unknown type"
}
